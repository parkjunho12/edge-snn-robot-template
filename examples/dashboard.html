<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMG Streaming Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9em;
            color: #666;
            font-weight: 600;
        }

        input, select, button {
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .status-card {
            flex: 1;
            min-width: 150px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .status-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
        }

        .status-unit {
            font-size: 0.9em;
            color: #999;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .prediction-display {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .prediction-label {
            font-size: 1em;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .prediction-value {
            font-size: 4em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .confidence-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 15px;
        }

        .confidence-fill {
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            transition: width 0.3s;
            border-radius: 10px;
        }

        .log-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #667eea;
            padding-left: 10px;
        }

        .log-timestamp {
            color: #858585;
        }

        .log-info {
            color: #4ec9b0;
        }

        .log-error {
            color: #f48771;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .streaming-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #4caf50;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† EMG Streaming Dashboard</h1>
        <p class="subtitle">Real-time inference visualization with TensorRT acceleration</p>

        <div class="controls">
            <div class="control-group">
                <label>Server URL</label>
                <input type="text" id="serverUrl" value="http://localhost:8000" style="width: 250px;">
            </div>
            
            <div class="control-group">
                <label>Duration (seconds)</label>
                <input type="number" id="duration" value="30" min="1" max="3600">
            </div>

            <div class="control-group">
                <label>FPS</label>
                <input type="number" id="fps" value="30" min="1" max="60">
            </div>

            <div class="control-group">
                <label>Backend</label>
                <select id="backend">
                    <option value="true">TensorRT</option>
                    <option value="false">PyTorch</option>
                </select>
            </div>

            <div class="control-group">
                <label>&nbsp;</label>
                <button id="startBtn" onclick="startStream()">‚ñ∂ Start Stream</button>
            </div>

            <div class="control-group">
                <label>&nbsp;</label>
                <button id="stopBtn" onclick="stopStream()" disabled>‚èπ Stop Stream</button>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-card">
                <div class="status-label">Frames Processed</div>
                <div class="status-value" id="frameCount">0</div>
            </div>
            <div class="status-card">
                <div class="status-label">Latency</div>
                <div class="status-value" id="latency">0<span class="status-unit">ms</span></div>
            </div>
            <div class="status-card">
                <div class="status-label">FPS</div>
                <div class="status-value" id="actualFps">0</div>
            </div>
            <div class="status-card">
                <div class="status-label">CPU Usage</div>
                <div class="status-value" id="cpuUsage">0<span class="status-unit">%</span></div>
            </div>
        </div>

        <div class="prediction-display">
            <div class="prediction-label">Current Prediction</div>
            <div class="prediction-value" id="prediction">-</div>
            <div class="prediction-label">Confidence</div>
            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceBar" style="width: 0%"></div>
            </div>
            <div style="margin-top: 10px; font-size: 1.2em;" id="confidenceText">0%</div>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <div class="chart-title">Latency Over Time</div>
                <canvas id="latencyChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Prediction Distribution</div>
                <canvas id="predictionChart"></canvas>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-title">üìä Event Log</div>
            <div class="log-container" id="logContainer"></div>
        </div>
    </div>

    <script>
        let eventSource = null;
        let latencyData = [];
        let predictionCounts = [0, 0, 0, 0, 0, 0, 0];
        let frameCount = 0;
        let lastTimestamp = null;
        let latencyChart, predictionChart;

        // Initialize charts
        function initCharts() {
            const latencyCtx = document.getElementById('latencyChart').getContext('2d');
            latencyChart = new Chart(latencyCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Latency (ms)',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Latency (ms)'
                            }
                        },
                        x: {
                            display: false
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            const predictionCtx = document.getElementById('predictionChart').getContext('2d');
            predictionChart = new Chart(predictionCtx, {
                type: 'bar',
                data: {
                    labels: ['Class 0', 'Class 1', 'Class 2', 'Class 3', 'Class 4', 'Class 5', 'Class 6'],
                    datasets: [{
                        label: 'Count',
                        data: predictionCounts,
                        backgroundColor: [
                            '#667eea', '#764ba2', '#f093fb', '#4facfe',
                            '#43e97b', '#fa709a', '#fee140'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 50 entries
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        function updateCharts(data) {
            // Update latency chart
            if (latencyData.length > 100) {
                latencyData.shift();
                latencyChart.data.labels.shift();
            }
            latencyData.push(data.latency_ms);
            latencyChart.data.labels.push(data.frame);
            latencyChart.data.datasets[0].data = latencyData;
            latencyChart.update('none');

            // Update prediction chart
            predictionCounts[data.prediction]++;
            predictionChart.data.datasets[0].data = predictionCounts;
            predictionChart.update('none');
        }

        function updateDisplay(data) {
            addLog(`Frame ${data.frame}: Latency=${data.latency_ms.toFixed(2)}ms, CPU=${data.cpu_percent.toFixed(1)}%, Pred=${data.prediction}, Conf=${(data.confidence * 100).toFixed(1)}%`);
            document.getElementById('frameCount').textContent = data.frame;
            document.getElementById('latency').innerHTML = 
                `${data.latency_ms.toFixed(2)}<span class="status-unit">ms</span>`;
            document.getElementById('cpuUsage').innerHTML = 
                `${data.cpu_percent.toFixed(1)}<span class="status-unit">%</span>`;
            
            // Calculate FPS
            if (lastTimestamp) {
                const fps = 1000 / (data.timestamp - lastTimestamp);
                document.getElementById('actualFps').textContent = fps.toFixed(1);
            }
            lastTimestamp = data.timestamp;

            // Update prediction display
            document.getElementById('prediction').textContent = data.prediction;
            const confidence = (data.confidence * 100).toFixed(1);
            document.getElementById('confidenceText').textContent = confidence + '%';
            document.getElementById('confidenceBar').style.width = confidence + '%';
        }
        let streamController = null;
        let streamReader = null;
        let streamActive = false;

        function startStream() {
            const serverUrl = document.getElementById('serverUrl').value;
            const duration = parseFloat(document.getElementById('duration').value);
            const fps = parseInt(document.getElementById('fps').value);
            const usePytorch = document.getElementById('backend').value === 'true';

            // Reset counters
            frameCount = 0;
            latencyData = [];
            predictionCounts = [0, 0, 0, 0, 0, 0, 0];
            lastTimestamp = null;

            // Update UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            addLog(`Starting stream: ${duration}s @ ${fps} FPS (Backend: ${usePytorch ? 'PyTorch' : 'TensorRT'})`);

            // Create EventSource
            const config = {
                duration_seconds: duration,
                use_tensorrt: usePytorch,
                fps: fps,
                preprocess: true
            };
            streamController = new AbortController();
            streamActive = true;
            

            // Use fetch for POST with streaming
            fetch(`${serverUrl}/infer/stream`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(config),
                signal: streamController.signal
            }).then(response => {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                function read() {
                    if (!streamActive) {
                        if (streamReader) {
                            streamReader.cancel().catch(() => {});
                        }
                        return;
                    }

                    reader.read().then(({done, value}) => {
                        if (done) {
                            stopStream();
                            return;
                        }
                        
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        lines.forEach(line => {
                            handleSSELine(line);
                        });

                        read();
                    }).catch(error => {
                        if (streamActive) {   // abortÎêú Í≤ΩÏö∞Ïóî Î°úÍ∑∏Îßå Ï°∞Ïö©Ìûà ÎÑòÍ∏∏ ÏàòÎèÑ ÏûàÏùå
                            addLog(`Stream error: ${error}`, 'error');
                        }
                        stopStream();
                    });
                }

                read();
            }).catch(error => {
                addLog(`Connection error: ${error}`, 'error');
                stopStream();
            });
        }
        function handleSSELine(line) {
            // Í≥µÎ∞± Ï†úÍ±∞
            const trimmed = line.trim();
            if (!trimmed) return;
            // 'data:'Î°ú ÏãúÏûëÌïòÎäî ÎùºÏù∏Îßå Ï≤òÎ¶¨
            if (!trimmed.startsWith('data:')) {
                return;
            }
        
            // 'data:' Ï†úÍ±∞ ÌõÑ ÎÇòÎ®∏ÏßÄÎßå Í∞ÄÏ†∏Ïò§Í∏∞
            const payload = trimmed.slice(5).trim(); // 'data:' Í∏∏Ïù¥ 5
            // Îπà payloadÍ±∞ÎÇò, [DONE] Í∞ôÏùÄ Ïª®Ìä∏Î°§ Î©îÏãúÏßÄÎ©¥ Î¨¥Ïãú
            if (!payload || payload === '[DONE]') {
                return;
            }
        
            try {
                const data = JSON.parse(payload);
                handleStreamData(data);
            } catch (e) {
                console.error('Parse error for line:', trimmed, e);
                addLog(`Parse error: ${e.message}`, 'error');
            }
        }
        
        function handleStreamData(data) {
            if (data.error) {
                addLog(`Error: ${data.error}`, 'error');
            } else if (data.status === 'completed') {
                addLog(`Stream completed: ${data.total_frames} frames in ${data.duration_seconds.toFixed(2)}s`, 'info');
                stopStream();
            } else {
                updateDisplay(data);
                updateCharts(data);
                
                if (data.frame % 30 === 0) {
                    addLog(`Frame ${data.frame}: Pred=${data.prediction}, Conf=${(data.confidence * 100).toFixed(1)}%`);
                }
            }
        }

        function stopStream() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            addLog('Stream stopped');
        }

        // Initialize on load
        window.onload = function() {
            initCharts();
            addLog('Dashboard initialized');
        };
    </script>
</body>
</html>